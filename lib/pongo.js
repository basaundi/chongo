// Generated by CoffeeScript 1.6.3
(function() {
  var Collection, Connection, Cursor, Database, Document, Namespace, ObjectId, Pongo, Query, arrComp, selectors, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  arrComp = function(x, v) {
    var s, _i, _len;
    for (_i = 0, _len = x.length; _i < _len; _i++) {
      s = x[_i];
      if (s === v) {
        return true;
      }
    }
    return false;
  };

  selectors = {
    $gt: function(x, v) {
      return x > v;
    },
    $gte: function(x, v) {
      return x >= v;
    },
    $lt: function(x, v) {
      return x < v;
    },
    $lte: function(x, v) {
      return x <= v;
    },
    $in: function(x, v) {
      return __indexOf.call(v, x) >= 0;
    },
    match: function(x, v) {
      var op, val;
      for (op in v) {
        val = v[op];
        if (!this[op](x, val)) {
          return false;
        }
      }
      return true;
    }
  };

  Query = function(q) {
    return function(d) {
      var k, m, s, v, x, _i, _len, _ref;
      for (k in q) {
        v = q[k];
        x = d;
        _ref = k.split('.');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          s = _ref[_i];
          x = x[s];
        }
        if (v instanceof Object) {
          if (Object.keys(v)[0][0] === '$') {
            m = selectors.match(x, v);
          } else {
            m = JSON.stringify(v) === JSON.stringify(x);
          }
        } else if (Array.isArray(x)) {
          m = arrComp(x, v);
        } else {
          m = x === v;
        }
        if (!m) {
          return false;
        }
      }
      return true;
    };
  };

  Cursor = (function() {
    function Cursor(col, index, query) {
      this.col = col;
      this.index = index;
      this.query = query;
      this.doc = null;
      this.started = false;
      this.done = false;
      this.i = 0;
      this.n = 0;
    }

    Cursor.prototype.load = function() {
      this.started = true;
      return this.match = Query(this.query);
    };

    Cursor.prototype.fetch = function() {
      var oid;
      if (!this.started) {
        this.load();
      }
      this.doc = null;
      while (!((this.doc != null) || this.i >= this.index.length)) {
        oid = this.index[this.i++];
        this.doc = new Document(this.col, oid);
        if (!this.match(this.doc.data)) {
          this.doc = null;
        }
      }
      if (this.doc != null) {
        ++this.n;
      } else {
        this.done = true;
      }
      return this.doc;
    };

    Cursor.prototype.pop = function() {
      var doc;
      if (this.doc == null) {
        return null;
      }
      this.index.splice(--this.i, 1);
      doc = this.doc;
      this.doc = null;
      return doc;
    };

    Cursor.prototype.hasNext = function() {
      if (this.doc != null) {
        return true;
      }
      if (this.done) {
        return false;
      }
      this.fetch();
      return !this.done;
    };

    Cursor.prototype.next = function() {
      var doc;
      if (this.doc == null) {
        this.fetch();
      }
      if (this.doc == null) {
        throw new Error("No more data.");
      }
      doc = this.doc.data;
      this.doc = null;
      return doc;
    };

    Cursor.prototype.toArray = function() {
      var a;
      a = [];
      while (this.hasNext()) {
        a.push(this.next());
      }
      return a;
    };

    return Cursor;

  })();

  /*
  class SimpleIndex extends Array
    insert: (x) ->
      @.push(x._id)
      if x._id > @max
        @max = x._id
      else # Uncommon for ObjectId
        @.sort()
  */


  /*
  IndexedCollection =
    # Indexes #
    create_index: (key_or_list) ->
      throw 'Not implemented'
  
    ensure_index: (key_or_list) ->
      throw 'Not implemented'
  
    drop_index: (index_name) ->
      throw 'Not implemented'
  
    drop_indexes: () ->
      throw 'Not implemented'
  
  class SimpleIndex
    constructor: (arr) ->
      @arr = arr
  
    insert: (x) ->
      @arr.push(x._id)
      @length = @arr.length
      if x._id > @max
        @max = x._id
      else # Uncommon for ObjectId
        @arr.sort()
  
  class Collection
    constructor: (@database, @name, create=false) ->
      @ns = @database.name + '.' + @name
      @main_index = @database.connection.get(@ns) || []
      @main_index = new SimpleIndex(@main_index)
  
    # CRUD #
    save: (to_save) ->
      type_name = Object.prototype.toString.call(to_save)
      if type_name isnt '[object Object]'
        throw new TypeError("cannot save object of type #{type_name}")
      if '_id' not in to_save
        return @insert(to_save)
      @update({'_id': to_save['_id']}, to_save, True)
      to_save['id'] || null
  
    insert: (doc_or_docs) ->
      docs = doc_or_docs
      if not Array.isArray(docs)
        return_one = true
        docs = [docs]
  
      for doc in docs
        @_fix_and_insert(doc)
  
      if return_one
        return docs[0]._id || null
      else
        return (doc._id for doc in docs)
  
    update: (query, update, upsert=False, multi=False) ->
      document = @database.fix_incoming(update, @)
      # TODO:
  
    remove: (query, just_one=false) ->
      throw 'Not implemented'
  
    find: (spec=null, fields = null, skip = 0, limit = 0) ->
      throw 'Not implemented'
  
    findOne: (spec_or_id=null) ->
      throw 'Not implemented'
  
    find_and_modify: (query={}, update=null, upsert=false, sort=null) ->
      throw 'Not implemented'
  
    # cursor op #
    count: () -> return @main_index.length
  
    distinct: (key) ->
      # TODO: Maybe cache?
      throw 'Not implemented'
  
    # management #
    rename: (new_name) ->
      # TODO: rename documents and indexes
      throw 'Not implemented'
  
    drop: ()->
      # TODO: delete documents and indexes
      throw 'Not implemented'
  
    # mapReduce #
    map_reduce: (map, reduce, out) ->
      throw 'Not implemented'
  
    inline_map_reduce: (map, reduce) ->
      throw 'Not implemented'
  
  
  class Database
    constructor: (@connection, @name) ->
  
    col: (collection) ->
      new Collection(@, @col)
  
    collection_names: ()->
      try
        collections = @connection.get(@name, 'system.namespaces')
      catch e # TypeError: the collection does not exist.
        collections = []
      collections
  
    drop_collection: (col)->
      # FIXME: Drop items and indexes
      @connection.del(@name, col)
  
  class ObjectId_ extends Number
    @inc: ~~(Math.random() * 0xFFFFFF)
    @getInc: () ->
      v = @inc
      @inc = (@inc + 1) % 0xFFFFFF
      v
  
    @generate: (hostname, pid) ->
      v  = ((new Date).getTime() / 1000) << 8
      v += hostname << 5
      v += pid << 3
      v += @getInc()
  
    toString: () -> 'ObjectId("' + @valueOf() +'")'
    valueOf: () -> super.toString(16)
    generationTime: () ->
      throw 'Not implemented'
  
  class Connection
    constructor: (@storage) ->
      @startup_log = @get('local', 'startup_log')
      if not @startup_log?
        @startup_log = { 'hostname' : ~~(Math.random() * 0xFFFFFF) }
      else
        @startup_log = @startup_log[0]
      @startup_log.pid = ~~(Math.random() * 0xFFFF)
      @set('local', 'startup_log', [@startup_log])
  
    get: (db, collection) ->
      JSON.parse(@storage.getItem(db, collection))
  
    set: (db, collection, v) ->
      @storage.setItem(db, collection, JSON.stringify(v))
  
    del: (db, collection) ->
      @storage.removeItem(db, collection)
  
    db: (name)->
      new Database(@, name)
  
    database_names: ()->
      try
        databases = @connection.get('local', 'system.databases')
      catch e # TypeError: the collection does not exist.
        databases = []
      databases
  
    drop_database: (db) ->
      # TODO: drop all collections with indexes.
      throw 'Not implemented'
  
    copy_database: (from_name, to_name) ->
      # TODO: copy all collections.
      # TODO: copy_collection.
      throw 'Not implemented'
  
    ObjectId: (hex=null)->
      if hex?
        v = parseInt(hex, 16)
        v.prototype = ObjectId_
      else v = ObjectId_.generate(@startup_log.hostname, @startup_log.pid)
      v
  */


  ObjectId = (function() {
    ObjectId.inc = ~~(Math.random() * 0xFFFFFF);

    ObjectId.hostname = ObjectId.inc;

    ObjectId.pid = ~~(Math.random() * 0xFFFFFF);

    ObjectId.getInc = function() {
      var v;
      v = this.inc;
      this.inc = (this.inc + 1) % 0xFFFFFF;
      return v;
    };

    function ObjectId(hex) {
      if (hex == null) {
        hex = null;
      }
      if (hex != null) {
        this.v = hex;
      } else {
        this.v = this.constructor.generate();
      }
    }

    ObjectId.generate = function() {
      var v;
      v = this._pad("00000000", ~~((new Date).getTime() / 1000));
      v += this._pad("000000", this.hostname);
      v += this._pad("0000", this.pid);
      v += this._pad("000000", this.getInc());
      return v;
    };

    ObjectId.prototype.toString = function() {
      return 'ObjectId("#{@v}")';
    };

    ObjectId.prototype.valueOf = function() {
      return this.v;
    };

    ObjectId._pad = function(f, v) {
      var t;
      t = v.toString(16);
      return (f + t).substring(t.length);
    };

    return ObjectId;

  })();

  Namespace = (function() {
    function Namespace(con, _id, data) {
      this.con = con;
      this._id = _id;
      this.data = data;
      this.ns = '.';
      if (this.data == null) {
        this.load();
      }
    }

    Namespace.prototype.load = function() {
      return this.data = this.get('') || {
        'sub': []
      };
    };

    Namespace.prototype.store = function() {
      return this.set('', this.data);
    };

    Namespace.prototype.destroy = function() {
      return this.del('');
    };

    Namespace.prototype.get = function(reg) {
      return this.con.get(this.ns + this._id + reg);
    };

    Namespace.prototype.set = function(reg, v) {
      return this.con.set(this.ns + this._id + reg, v);
    };

    Namespace.prototype.del = function(reg) {
      return this.con.del(this.ns + this._id + reg);
    };

    return Namespace;

  })();

  Document = (function(_super) {
    __extends(Document, _super);

    function Document(con, _id, data) {
      this.con = con;
      this._id = _id;
      this.data = data;
      this.ns = '.$$';
      if (this.data == null) {
        this.load();
      }
    }

    return Document;

  })(Namespace);

  Collection = (function(_super) {
    __extends(Collection, _super);

    function Collection() {
      _ref = Collection.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Collection.prototype.find = function(query) {
      return new Cursor(this, this.data.sub, query);
    };

    Collection.prototype.insert = function(doc) {
      var d, _i, _len;
      if (Array.isArray(doc)) {
        for (_i = 0, _len = doc.length; _i < _len; _i++) {
          d = doc[_i];
          this.insert(d);
        }
        return;
      }
      if (doc._id == null) {
        doc._id = new ObjectId().valueOf();
      }
      doc = new Document(this, doc._id, doc);
      doc.store();
      this.data.sub.push(doc._id.valueOf());
      return this.store();
    };

    Collection.prototype.update = function(spec, new_doc) {
      var cur, doc;
      cur = this.find(spec);
      doc = cur.fetch();
      new_doc._id = doc._id;
      doc.data = new_doc;
      doc.store();
      return this.store;
    };

    Collection.prototype.remove = function(spec) {
      var cur, doc;
      cur = this.find(spec);
      while (cur.hasNext()) {
        doc = cur.pop();
        doc.destroy();
      }
      return this.store;
    };

    Collection.prototype.count = function() {
      return this.data.sub.length;
    };

    return Collection;

  })(Namespace);

  Database = (function(_super) {
    __extends(Database, _super);

    function Database() {
      _ref1 = Database.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Database.prototype.col = function(col) {
      return new Collection(this, col);
    };

    return Database;

  })(Namespace);

  Connection = (function() {
    function Connection(store) {
      this.store = store;
      this.ns = '$';
      this.data = this.get('.local.system.pongo');
      if (this.data == null) {
        this.data = {};
        this.data.hostname = ObjectId.hostname;
        this.set('.local.system.pongo', this.data);
      }
    }

    Connection.prototype.db = function(db) {
      return new Database(this, db);
    };

    Connection.prototype.get = function(reg) {
      var v;
      console.log('Getting registry ', reg);
      v = this.store.getItem(this.ns + reg);
      return v && JSON.parse(v);
    };

    Connection.prototype.set = function(reg, v) {
      console.log('Setting registry ', reg, ' to value ', v);
      return this.store.setItem(this.ns + reg, JSON.stringify(v));
    };

    Connection.prototype.del = function(reg) {
      return this.store.removeItem(this.ns + reg);
    };

    return Connection;

  })();

  Pongo = this.Pongo = {
    'Connection': Connection,
    'Database': Database,
    'Collection': Collection,
    'Query': Query
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Pongo;
  }

}).call(this);
